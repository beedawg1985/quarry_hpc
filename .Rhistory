load("/Users/barneyharris/Downloads/bestras(1).RData")
circle.sf.raw <- data.frame(x = circlexy(f$par)[,1],
y = circlexy(f$par)[,2]) %>%
st_as_sf(coords=c('x','y'))
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
xy[1,1] <- -1.5
plot(xy,asp=1
,xlim=c(-1,1)
,ylim=c(-1,1)
)
f = fitSS(xy)
lines(circlexy(f$par))
# OR
xy.sf = st_read('/Users/barneyharris/sos/points.kml') %>%
st_transform(27700)
xy <- xy.sf %>%
st_coordinates()
xy <- cbind(xy[,1],xy[,2])
require(tidyverse)
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
xy[1,1] <- -1.5
plot(xy,asp=1
,xlim=c(-1,1)
,ylim=c(-1,1)
)
f = fitSS(xy)
lines(circlexy(f$par))
require(tidyverse)
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
f = fitSS(xy)
lines(circlexy(f$par))
circlexy
# example dataset
xy = sim_circles(5) # generate points
xy
f = fitSS(xy)
circlexy <- function(xyr, n=180){
theta = seq(0,2*pi,len=n)
cbind(xyr[1] + xyr[3]*cos(theta),
xyr[2] + xyr[3]*sin(theta)
)
}
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
require(tidyverse)
circlexy <- function(xyr, n=180){
theta = seq(0,2*pi,len=n)
cbind(xyr[1] + xyr[3]*cos(theta),
xyr[2] + xyr[3]*sin(theta)
)
}
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
f = fitSS(xy)
lines(circlexy(f$par))
# OR
stone.points = st_read('/Users/barneyharris/sos/points.kml') %>%
st_transform(27700)
require(sf)
circlexy <- function(xyr, n=180){
theta = seq(0,2*pi,len=n)
cbind(xyr[1] + xyr[3]*cos(theta),
xyr[2] + xyr[3]*sin(theta)
)
}
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
f = fitSS(xy)
lines(circlexy(f$par))
# OR
stone.points = st_read('/Users/barneyharris/sos/points.kml') %>%
st_transform(27700)
xy <- stone.points %>%
st_coordinates()
xy <- cbind(xy[,1],xy[,2])
maxX <- max(xy[,1])
maxY <- max(xy[,2])
xyNew <- xy
xyNew[,1] <-  xy[,1]/maxX
xyNew[,2] <-  xy[,2]/maxY
f = fitSS(xyNew)
circleLines <- circlexy(f$par)
plot(xyNew,asp=1
,xlim=c(min(circleLines[,1]),max(circleLines[,1]))
,ylim=c(min(circleLines[,2]),max(circleLines[,2]))
)
lines(circlexy(f$par))
xyNew[,1]
xyNew.sf.raw <- data.frame(x = xyNew[,1],
y = xyNew[,1][,2]) %>%
st_as_sf(coords=c('x','y'))
xyNew.sf.raw <- data.frame(x = xyNew[,1],
y = xyNew[,2]) %>%
st_as_sf(coords=c('x','y'))
xyNew.sf.raw
circle.sf.raw <- data.frame(x = circlexy(f$par)[,1],
y = circlexy(f$par)[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('circle.raw.kml')
xyNew.sf.raw <- data.frame(x = xyNew[,1],
y = xyNew[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('xyNew.raw.kml')
getwd()
maxX
maxY
maxX <- 200000
maxY <- 200000
xyNew <- xy
xyNew[,1] <-  xy[,1]/maxX
xyNew[,2] <-  xy[,2]/maxY
xyNew[,1]
xyNew[,2]
f = fitSS(xyNew)
circleLines <- circlexy(f$par)
plot(xyNew,asp=1
,xlim=c(min(circleLines[,1]),max(circleLines[,1]))
,ylim=c(min(circleLines[,2]),max(circleLines[,2]))
)
lines(circlexy(f$par))
circle.sf.raw <- data.frame(x = circlexy(f$par)[,1],
y = circlexy(f$par)[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('circle.raw.kml')
circle.sf.raw <- data.frame(x = circlexy(f$par)[,1],
y = circlexy(f$par)[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('circle.raw.kml',append=F)
xyNew.sf.raw <- data.frame(x = xyNew[,1],
y = xyNew[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('xyNew.raw.kml',append=F)
circle.sf <- data.frame(x = circlexy(f$par)[,1] * maxX,
y = circlexy(f$par)[,2] * maxY) %>%
st_as_sf(coords=c('x','y'),crs=27700)
xy.sf <-
data.frame(x = xyNew[,1] * maxX,
y = xyNew[,2] * maxY) %>%
st_as_sf(coords=c('x','y'),crs=27700)
circle.sf %>% st_write('circle.kml',
append=F)
xy.sf %>% st_write('xy.kml',
append=F)
plot(circle.sf)
xy <- stone.points %>%
st_coordinates() %>%
cbind(.[,1],.[,2])
xy
xy
xy <- stone.points %>%
st_coordinates()
xy
xy <- cbind(xy[,1],xy[,2])
xy
round(max(xy))
round(max(xy),10000)
round(max(xy),10000)
round(max(xy),1)
floor(max(xy),1)
?round
signif(max(xy),1)
a <- signif(max(xy),1)
# copy xy object
xyNew <- xy
xyNew[,1] <-  xy[,1]/diviser
xyNew[,2] <-  xy[,2]/diviser
circlexy <- function(xyr, n=360){
theta = seq(0,2*pi,len=n)
cbind(xyr[1] + xyr[3]*cos(theta),
xyr[2] + xyr[3]*sin(theta)
)
}
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
f = fitSS(xy)
lines(circlexy(f$par))
# Wawn Mawn model
stone.points = st_read('/Users/barneyharris/sos/points.kml') %>%
st_transform(27700)
# convert to matrix
xy <- stone.points %>%
st_coordinates() %>%
xy <- cbind(xy[,1],xy[,2])
# convert to matrix
xy <- stone.points %>%
st_coordinates()
xy <- cbind(xy[,1],xy[,2])
# found diviser to convert coords to close to 1
diviser <- signif(max(xy),1)
# copy xy object
xyNew <- xy
xyNew[,1] <-  xy[,1]/diviser
xyNew[,2] <-  xy[,2]/diviser
f = fitSS(xyNew)
circleLines <- circlexy(f$par)
plot(xyNew,asp=1
,xlim=c(min(circleLines[,1]),max(circleLines[,1]))
,ylim=c(min(circleLines[,2]),max(circleLines[,2]))
)
lines(circlexy(f$par))
?snow::getMPIcluster()
library(Rmpi)
install.packages('Rmpi')
library(utils)
sample(1,100)
sample(1,1:100)
sample(1,1:100)
sample(1:100,1)
sample(1:100,1)
sample(1:100,1)
sample(1:100,1)
rnorm(sample(1:100,1),n=10000)
?parallel::makeCluster
161:(161+160)
R.version()
R.Version()
devtools::install_github("AntoniusGolly/cmgo")
prepData <- readRDS("~/Documents/git/quarry_hpc/data/prepData_alllocs_norm_maxdiff01_smpper0.RDS")
p <- prepData[[1]]$pol
p
library(sf)
p <- prepData[[1]]$pol
p
# include the package (required for every start of an R session)
library(cmgo)
getwd()
# set your working directory
setwd(getwd()) # in that folder an "input" folder must exist which contains one or more files with point data
# load parameter
par = CM.par()
par$bank.interpolate.max.dist = 4 # set roughly to your expected channel width
load(file='cvdev/gfilter.RDS')
# revised cv parameters based on results of exploratory values above
cvGrids <-
list(
nn = data.frame(expand.grid(
nmaxVals = seq(5,300,by=5),
nminVals = 1
)),
idw = data.frame(expand.grid(
nmaxVals = seq(5,300,by=5),
nminVals = 1,
idpVals = seq(0.2,10,by=0.2)
)),
ok = data.frame(expand.grid(
nmaxVals = seq(5,300,by=5),
nminVals = 1
)),
gspline = data.frame(expand.grid(
tensionVals = c(seq(0.0001,0.1,by=0.002),
seq(0.15,0.7,by=0.05)),
smoothVals = seq(2,30,by=5),
nminVals = seq(30,150,by=20)
)),
gbicubic = data.frame(expand.grid(
stepVals = seq(1,20,by=1),
lamVals = c(seq(0.0001,0.1,by=0.005),seq(0.1,1.4,by=0.1))
)),
gfilter = data.frame(expand.grid(
radVals = seq(5,50,by=5),
filtVals = gfilter.params$filtcomb_number
))
)
# revised cv parameters based on results of exploratory values above
cvGrids <-
list(
nn = data.frame(expand.grid(
nmaxVals = seq(5,300,by=5),
nminVals = 1
)),
idw = data.frame(expand.grid(
nmaxVals = seq(5,300,by=5),
nminVals = 1,
idpVals = seq(0.2,10,by=0.2)
)),
ok = data.frame(expand.grid(
nmaxVals = seq(5,300,by=5),
nminVals = 1
)),
gspline = data.frame(expand.grid(
tensionVals = c(seq(0.0001,0.1,by=0.002),
seq(0.15,0.7,by=0.05)),
smoothVals = seq(2,30,by=5),
nminVals = seq(30,150,by=20)
)),
gbicubic = data.frame(expand.grid(
stepVals = seq(1,20,by=1),
lamVals = c(seq(0.0001,0.1,by=0.005),seq(0.1,1.4,by=0.1))
))
)
View(cvGrids)
# revised cv parameters based on results of exploratory values above
cvGrids <-
list(
nn = data.frame(expand.grid(
nmaxVals = seq(5,300,by=5),
nminVals = 1
)),
idw = data.frame(expand.grid(
nmaxVals = seq(5,300,by=5),
nminVals = 1,
idpVals = seq(0.2,10,by=0.2)
)),
ok = data.frame(expand.grid(
nmaxVals = seq(5,300,by=5),
nminVals = 1
)),
gspline = data.frame(expand.grid(
tensionVals = c(seq(0.0001,0.1,by=0.002),
seq(0.15,0.7,by=0.05)),
smoothVals = c(1,seq(5,50,by=5)),
nminVals = seq(10,260,by=20)
)),
gbicubic = data.frame(expand.grid(
stepVals = seq(1,20,by=1),
lamVals = c(seq(0.0001,0.1,by=0.005),seq(0.1,1.4,by=0.1))
))
)
cvGrids
# revised cv parameters based on results of exploratory values above
cvGrids <-
list(
nn = data.frame(expand.grid(
nmaxVals = seq(5,300,by=5),
nminVals = 1
)),
idw = data.frame(expand.grid(
nmaxVals = seq(5,300,by=5),
nminVals = 1,
idpVals = seq(0.2,10,by=0.2)
)),
ok = data.frame(expand.grid(
nmaxVals = seq(5,300,by=5),
nminVals = 1
)),
gspline = data.frame(expand.grid(
tensionVals = c(seq(0.0001,0.1,by=0.002),
seq(0.15,0.7,by=0.05)),
smoothVals = c(1,seq(10,50,by=10)),
nminVals = seq(10,260,by=20)
)),
gbicubic = data.frame(expand.grid(
stepVals = seq(1,20,by=1),
lamVals = c(seq(0.0001,0.1,by=0.005),seq(0.1,1.4,by=0.1))
))
)
161+160
322+160
methods <- list('rfsp','nn','ok','tin',
'idw','gbicubic','gspline')
tasks <- expand.grid(methods,1:60)                                # check this !
tasks
setwd("~/Documents/git/quarry_hpc/data")
setwd("~/Documents/git/quarry_hpc")
f <- 'data/prepData_alllocs_maxdiff01_smpper0.RDS'                # check this !
prepData <- readRDS(f)
length(prepData)

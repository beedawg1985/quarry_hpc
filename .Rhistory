load("/Users/barneyharris/Downloads/bestras(1).RData")
circle.sf.raw <- data.frame(x = circlexy(f$par)[,1],
y = circlexy(f$par)[,2]) %>%
st_as_sf(coords=c('x','y'))
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
xy[1,1] <- -1.5
plot(xy,asp=1
,xlim=c(-1,1)
,ylim=c(-1,1)
)
f = fitSS(xy)
lines(circlexy(f$par))
# OR
xy.sf = st_read('/Users/barneyharris/sos/points.kml') %>%
st_transform(27700)
xy <- xy.sf %>%
st_coordinates()
xy <- cbind(xy[,1],xy[,2])
require(tidyverse)
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
xy[1,1] <- -1.5
plot(xy,asp=1
,xlim=c(-1,1)
,ylim=c(-1,1)
)
f = fitSS(xy)
lines(circlexy(f$par))
require(tidyverse)
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
f = fitSS(xy)
lines(circlexy(f$par))
circlexy
# example dataset
xy = sim_circles(5) # generate points
xy
f = fitSS(xy)
circlexy <- function(xyr, n=180){
theta = seq(0,2*pi,len=n)
cbind(xyr[1] + xyr[3]*cos(theta),
xyr[2] + xyr[3]*sin(theta)
)
}
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
require(tidyverse)
circlexy <- function(xyr, n=180){
theta = seq(0,2*pi,len=n)
cbind(xyr[1] + xyr[3]*cos(theta),
xyr[2] + xyr[3]*sin(theta)
)
}
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
f = fitSS(xy)
lines(circlexy(f$par))
# OR
stone.points = st_read('/Users/barneyharris/sos/points.kml') %>%
st_transform(27700)
require(sf)
circlexy <- function(xyr, n=180){
theta = seq(0,2*pi,len=n)
cbind(xyr[1] + xyr[3]*cos(theta),
xyr[2] + xyr[3]*sin(theta)
)
}
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
f = fitSS(xy)
lines(circlexy(f$par))
# OR
stone.points = st_read('/Users/barneyharris/sos/points.kml') %>%
st_transform(27700)
xy <- stone.points %>%
st_coordinates()
xy <- cbind(xy[,1],xy[,2])
maxX <- max(xy[,1])
maxY <- max(xy[,2])
xyNew <- xy
xyNew[,1] <-  xy[,1]/maxX
xyNew[,2] <-  xy[,2]/maxY
f = fitSS(xyNew)
circleLines <- circlexy(f$par)
plot(xyNew,asp=1
,xlim=c(min(circleLines[,1]),max(circleLines[,1]))
,ylim=c(min(circleLines[,2]),max(circleLines[,2]))
)
lines(circlexy(f$par))
xyNew[,1]
xyNew.sf.raw <- data.frame(x = xyNew[,1],
y = xyNew[,1][,2]) %>%
st_as_sf(coords=c('x','y'))
xyNew.sf.raw <- data.frame(x = xyNew[,1],
y = xyNew[,2]) %>%
st_as_sf(coords=c('x','y'))
xyNew.sf.raw
circle.sf.raw <- data.frame(x = circlexy(f$par)[,1],
y = circlexy(f$par)[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('circle.raw.kml')
xyNew.sf.raw <- data.frame(x = xyNew[,1],
y = xyNew[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('xyNew.raw.kml')
getwd()
maxX
maxY
maxX <- 200000
maxY <- 200000
xyNew <- xy
xyNew[,1] <-  xy[,1]/maxX
xyNew[,2] <-  xy[,2]/maxY
xyNew[,1]
xyNew[,2]
f = fitSS(xyNew)
circleLines <- circlexy(f$par)
plot(xyNew,asp=1
,xlim=c(min(circleLines[,1]),max(circleLines[,1]))
,ylim=c(min(circleLines[,2]),max(circleLines[,2]))
)
lines(circlexy(f$par))
circle.sf.raw <- data.frame(x = circlexy(f$par)[,1],
y = circlexy(f$par)[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('circle.raw.kml')
circle.sf.raw <- data.frame(x = circlexy(f$par)[,1],
y = circlexy(f$par)[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('circle.raw.kml',append=F)
xyNew.sf.raw <- data.frame(x = xyNew[,1],
y = xyNew[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('xyNew.raw.kml',append=F)
circle.sf <- data.frame(x = circlexy(f$par)[,1] * maxX,
y = circlexy(f$par)[,2] * maxY) %>%
st_as_sf(coords=c('x','y'),crs=27700)
xy.sf <-
data.frame(x = xyNew[,1] * maxX,
y = xyNew[,2] * maxY) %>%
st_as_sf(coords=c('x','y'),crs=27700)
circle.sf %>% st_write('circle.kml',
append=F)
xy.sf %>% st_write('xy.kml',
append=F)
plot(circle.sf)
xy <- stone.points %>%
st_coordinates() %>%
cbind(.[,1],.[,2])
xy
xy
xy <- stone.points %>%
st_coordinates()
xy
xy <- cbind(xy[,1],xy[,2])
xy
round(max(xy))
round(max(xy),10000)
round(max(xy),10000)
round(max(xy),1)
floor(max(xy),1)
?round
signif(max(xy),1)
a <- signif(max(xy),1)
# copy xy object
xyNew <- xy
xyNew[,1] <-  xy[,1]/diviser
xyNew[,2] <-  xy[,2]/diviser
circlexy <- function(xyr, n=360){
theta = seq(0,2*pi,len=n)
cbind(xyr[1] + xyr[3]*cos(theta),
xyr[2] + xyr[3]*sin(theta)
)
}
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
f = fitSS(xy)
lines(circlexy(f$par))
# Wawn Mawn model
stone.points = st_read('/Users/barneyharris/sos/points.kml') %>%
st_transform(27700)
# convert to matrix
xy <- stone.points %>%
st_coordinates() %>%
xy <- cbind(xy[,1],xy[,2])
# convert to matrix
xy <- stone.points %>%
st_coordinates()
xy <- cbind(xy[,1],xy[,2])
# found diviser to convert coords to close to 1
diviser <- signif(max(xy),1)
# copy xy object
xyNew <- xy
xyNew[,1] <-  xy[,1]/diviser
xyNew[,2] <-  xy[,2]/diviser
f = fitSS(xyNew)
circleLines <- circlexy(f$par)
plot(xyNew,asp=1
,xlim=c(min(circleLines[,1]),max(circleLines[,1]))
,ylim=c(min(circleLines[,2]),max(circleLines[,2]))
)
lines(circlexy(f$par))
?snow::getMPIcluster()
library(Rmpi)
install.packages('Rmpi')
library(utils)
assign(".MPIrun", function() {
if (mpi.comm.rank(0) > 0){
sys.load.image(".RData",TRUE)
.First.sys()
sink(file="/dev/null")
slaveLoop(makeMPImaster())
mpi.quit()
}
else {
makeMPIcluster()
.Last <<- function(){
cl <- getMPIcluster()
if (! is.null(cl))
stopCluster(cl)
mpi.quit()
}
}
}, envir = globalenv())
# set envs
userDataDir <<- '/home/tcrnbgh/Scratch/quarry_data'
grassMapset <<- paste0(userDataDir,'/grassdb/quarry/PERMANENT/')
grassLocation <<- paste0(userDataDir,'/grassdb/quarry/')
load(file='cvdev/gfilter.RDS')
# revised cv parameters based on results of exploratory values above
cvGrids <-
list(
nn = data.frame(expand.grid(
nmaxVals = seq(1,100,by=2),
nminVals = 1
)),
idw = data.frame(expand.grid(
nmaxVals = seq(2,100,by=2),
nminVals = 1,
idpVals = seq(0.2,10,by=0.2)
)),
ok = data.frame(expand.grid(
nmaxVals = seq(1,100,by=2),
nminVals = 1
)),
gspline = data.frame(expand.grid(
tensionVals = c(seq(0.0001,0.1,by=0.002),
seq(0.15,0.7,by=0.05)),
smoothVals = seq(2,30,by=5),
nminVals = seq(30,150,by=20)
)),
gbicubic = data.frame(expand.grid(
stepVals = seq(1,20,by=1),
lamVals = c(seq(0.0001,0.1,by=0.005),seq(0.1,1.4,by=0.1))
)),
gfilter = data.frame(expand.grid(
radVals = seq(5,50,by=5),
filtVals = gfilter.params$filtcomb_number
))
)
source('rscript/general_functions.R')
getwd()
setwd("~/Documents/git/quarry_hpc")
source('rscript/general_functions.R')
source('rscript/general_functions.R')
source('rscript/general_functions.R')
?clusterEvalQ
snow::clusterEvalQ
library(parallel)
library(future)
load("/Users/barneyharris/Downloads/g1.RData")
options(rgl.useNULL = FALSE)
library(rayshader)
rayshader::plot_gg(g1,multicore = TRUE,width=5,height=5,scale=250,windowsize=c(1400,866),
zoom = 0.55, phi = 30)
install.package('ggspatial')
install.packages('ggspatial')
g1
library(ggspatial)
library(ggplot2)
g1
library(ggspatial)
library(ggplot2)
library(rayshader)
g1
rm(g1)
load("/Users/barneyharris/Downloads/g1(1).RData")
g1
g1$theme <- ggplot2::theme_minimal()
g1
rayshader::plot_gg(g1,multicore = TRUE,width=5,height=5,scale=250,windowsize=c(1400,866),
zoom = 0.55, phi = 30)
render_snapshot('out.png')
g1$theme <- ggplot2::theme_grey()
g1$theme <- ggplot2::theme_grey(base_size = 8,
axis.text=element_blank(),
axis.title=element_blank(),
axis.ticks = element_blank())
g1$theme <- ggplot2::theme_grey(base_size = 8) +
ggplot2::theme(
axis.text=element_blank(),
axis.title=element_blank(),
axis.ticks = element_blank())
g1
rayshader::plot_gg(g1,multicore = TRUE,width=5,height=5,scale=250,windowsize=c(1400,866),
zoom = 0.55, phi = 30)
cat('hi',file='out.txt')
?save
outputDir
f <- 'data/prepData_alllocs_maxdiff01_smpper0.RDS'
prepData <- readRDS(f)
print('done!')
# these calls establish workers for parallel processing and retrieve the id of
# each worker. The id of the workers is tallied with a pre-existing GRASS mapset
# id, so each worker simultanesouly processes data in a single mapset to avoid
# conflicts.
# run
sessionTag <- str_replace(basename(f),'.RDS','')
sessionTag <- paste0(sessionTag,'')
prepDataTrunc <- prepData[1:70]
names(prepDataTrunc)
prepDataTrunc[[70]]
plot(prepDataTrunc[[70]]$tiles$a)
library(tuneRanger)
maskPoly = pd$pol
pd <- prepDataTrunc[[70]]
maskPoly = pd$pol
paramData=cvGrids
gLoc = grassLocation
outputDir = '/home/tcrnbgh/Scratch/quarry_data/data_output'
testCV = T # = T for test run
outputTag = sessionTag
intMethods=c(
'rfsp',
'nn','idw','ok','tin',
'gfilter',
'gspline'
)
trainingData <- pd$foldA$train
testData <- pd$foldA$all
trainingData
# grass params
gdb <- paste0(gLoc,Sys.getpid(),'/')
print(gdb)
# write points for gspline
st_write(trainingData$sf[,'elev'],
paste0('vector/intout_',maskPoly$fid,'_training.gpkg'),
delete_dsn=T)
# @@@@ needed to prevent freezing on run 279 ?!? !!!!
# paramData.c$gspline <- paramData.c$gspline %>%
#   slice(10:nrow(.))
# grass-based splines model ----
# training.sf <- trainingData$sf
# test.r <- testData$ras
library(sf)
# write points for gspline
st_write(trainingData$sf[,'elev'],
paste0('vector/intout_',maskPoly$fid,'_training.gpkg'),
delete_dsn=T)
# write points for gspline
st_write(trainingData$sf[,'elev'],
paste0('vector/intout_',maskPoly$fid,'_training.gpkg'),
delete_dsn=T)
Sys.getpid()
pd$pol$fid
print(gdb)
# grass params
gdb <- paste0(gLoc,pd$pol$fid,'/')
print(gdb)

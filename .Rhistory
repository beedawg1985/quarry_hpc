load("/Users/barneyharris/Downloads/bestras(1).RData")
circle.sf.raw <- data.frame(x = circlexy(f$par)[,1],
y = circlexy(f$par)[,2]) %>%
st_as_sf(coords=c('x','y'))
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
xy[1,1] <- -1.5
plot(xy,asp=1
,xlim=c(-1,1)
,ylim=c(-1,1)
)
f = fitSS(xy)
lines(circlexy(f$par))
# OR
xy.sf = st_read('/Users/barneyharris/sos/points.kml') %>%
st_transform(27700)
xy <- xy.sf %>%
st_coordinates()
xy <- cbind(xy[,1],xy[,2])
require(tidyverse)
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
xy[1,1] <- -1.5
plot(xy,asp=1
,xlim=c(-1,1)
,ylim=c(-1,1)
)
f = fitSS(xy)
lines(circlexy(f$par))
require(tidyverse)
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
f = fitSS(xy)
lines(circlexy(f$par))
circlexy
# example dataset
xy = sim_circles(5) # generate points
xy
f = fitSS(xy)
circlexy <- function(xyr, n=180){
theta = seq(0,2*pi,len=n)
cbind(xyr[1] + xyr[3]*cos(theta),
xyr[2] + xyr[3]*sin(theta)
)
}
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
require(tidyverse)
circlexy <- function(xyr, n=180){
theta = seq(0,2*pi,len=n)
cbind(xyr[1] + xyr[3]*cos(theta),
xyr[2] + xyr[3]*sin(theta)
)
}
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
f = fitSS(xy)
lines(circlexy(f$par))
# OR
stone.points = st_read('/Users/barneyharris/sos/points.kml') %>%
st_transform(27700)
require(sf)
circlexy <- function(xyr, n=180){
theta = seq(0,2*pi,len=n)
cbind(xyr[1] + xyr[3]*cos(theta),
xyr[2] + xyr[3]*sin(theta)
)
}
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
f = fitSS(xy)
lines(circlexy(f$par))
# OR
stone.points = st_read('/Users/barneyharris/sos/points.kml') %>%
st_transform(27700)
xy <- stone.points %>%
st_coordinates()
xy <- cbind(xy[,1],xy[,2])
maxX <- max(xy[,1])
maxY <- max(xy[,2])
xyNew <- xy
xyNew[,1] <-  xy[,1]/maxX
xyNew[,2] <-  xy[,2]/maxY
f = fitSS(xyNew)
circleLines <- circlexy(f$par)
plot(xyNew,asp=1
,xlim=c(min(circleLines[,1]),max(circleLines[,1]))
,ylim=c(min(circleLines[,2]),max(circleLines[,2]))
)
lines(circlexy(f$par))
xyNew[,1]
xyNew.sf.raw <- data.frame(x = xyNew[,1],
y = xyNew[,1][,2]) %>%
st_as_sf(coords=c('x','y'))
xyNew.sf.raw <- data.frame(x = xyNew[,1],
y = xyNew[,2]) %>%
st_as_sf(coords=c('x','y'))
xyNew.sf.raw
circle.sf.raw <- data.frame(x = circlexy(f$par)[,1],
y = circlexy(f$par)[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('circle.raw.kml')
xyNew.sf.raw <- data.frame(x = xyNew[,1],
y = xyNew[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('xyNew.raw.kml')
getwd()
maxX
maxY
maxX <- 200000
maxY <- 200000
xyNew <- xy
xyNew[,1] <-  xy[,1]/maxX
xyNew[,2] <-  xy[,2]/maxY
xyNew[,1]
xyNew[,2]
f = fitSS(xyNew)
circleLines <- circlexy(f$par)
plot(xyNew,asp=1
,xlim=c(min(circleLines[,1]),max(circleLines[,1]))
,ylim=c(min(circleLines[,2]),max(circleLines[,2]))
)
lines(circlexy(f$par))
circle.sf.raw <- data.frame(x = circlexy(f$par)[,1],
y = circlexy(f$par)[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('circle.raw.kml')
circle.sf.raw <- data.frame(x = circlexy(f$par)[,1],
y = circlexy(f$par)[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('circle.raw.kml',append=F)
xyNew.sf.raw <- data.frame(x = xyNew[,1],
y = xyNew[,2]) %>%
st_as_sf(coords=c('x','y')) %>%
st_write('xyNew.raw.kml',append=F)
circle.sf <- data.frame(x = circlexy(f$par)[,1] * maxX,
y = circlexy(f$par)[,2] * maxY) %>%
st_as_sf(coords=c('x','y'),crs=27700)
xy.sf <-
data.frame(x = xyNew[,1] * maxX,
y = xyNew[,2] * maxY) %>%
st_as_sf(coords=c('x','y'),crs=27700)
circle.sf %>% st_write('circle.kml',
append=F)
xy.sf %>% st_write('xy.kml',
append=F)
plot(circle.sf)
xy <- stone.points %>%
st_coordinates() %>%
cbind(.[,1],.[,2])
xy
xy
xy <- stone.points %>%
st_coordinates()
xy
xy <- cbind(xy[,1],xy[,2])
xy
round(max(xy))
round(max(xy),10000)
round(max(xy),10000)
round(max(xy),1)
floor(max(xy),1)
?round
signif(max(xy),1)
a <- signif(max(xy),1)
# copy xy object
xyNew <- xy
xyNew[,1] <-  xy[,1]/diviser
xyNew[,2] <-  xy[,2]/diviser
circlexy <- function(xyr, n=360){
theta = seq(0,2*pi,len=n)
cbind(xyr[1] + xyr[3]*cos(theta),
xyr[2] + xyr[3]*sin(theta)
)
}
sim_circles <- function(n,x=0,y=0,r=1,sd=0.05){
theta = runif(n, 0, 2*pi)
r = r + rnorm(n, mean=0, sd=sd)
cbind(x + r*cos(theta),
y + r*sin(theta)
)
}
fitSS <- function(xy,
a0=mean(xy[,1]),
b0=mean(xy[,2]),
r0 = mean(sqrt((xy[,1]-a0)^2 + (xy[,2]-b0)^2)),
...){
SS <- function(abr){
sum((abr[3] - sqrt((xy[,1]-abr[1])^2 + (xy[,2]-abr[2])^2))^2)
}
optim(c(a0,b0,r0), SS, ...)
}
# example dataset
xy = sim_circles(5) # generate points
f = fitSS(xy)
lines(circlexy(f$par))
# Wawn Mawn model
stone.points = st_read('/Users/barneyharris/sos/points.kml') %>%
st_transform(27700)
# convert to matrix
xy <- stone.points %>%
st_coordinates() %>%
xy <- cbind(xy[,1],xy[,2])
# convert to matrix
xy <- stone.points %>%
st_coordinates()
xy <- cbind(xy[,1],xy[,2])
# found diviser to convert coords to close to 1
diviser <- signif(max(xy),1)
# copy xy object
xyNew <- xy
xyNew[,1] <-  xy[,1]/diviser
xyNew[,2] <-  xy[,2]/diviser
f = fitSS(xyNew)
circleLines <- circlexy(f$par)
plot(xyNew,asp=1
,xlim=c(min(circleLines[,1]),max(circleLines[,1]))
,ylim=c(min(circleLines[,2]),max(circleLines[,2]))
)
lines(circlexy(f$par))
?snow::getMPIcluster()
library(Rmpi)
install.packages('Rmpi')
library(utils)
gLoc
grassLocation <<- paste0(userDataDir,'/grassdb/quarry/')
# set envs
userDataDir <<- '/home/tcrnbgh/Scratch/quarry_data'
grassMapset <<- paste0(userDataDir,'/grassdb/quarry/PERMANENT/')
grassLocation <<- paste0(userDataDir,'/grassdb/quarry/')
gLoc
# grass params
gLoc <- grassLocation
gLoc
# grass params
# gLoc <- grassLocation
gdb <- paste0(gLoc,pd$pol$fid,'/')
gLoc
# grass params
gLoc <- grassLocation
gLoc
grassLocation
# grass params
gLoc <- '/home/tcrnbgh/Scratch/quarry_data/grassdb/quarry'
gdb
# grass params
pd$pol$fid <- 1
gdb <- paste0(gLoc,'_pol',1)
gdb
gLoc
# grass params
# generate unique grass location name
gnLoc <- paste0(gLoc,'_pol',pd$pol$fid)
gnLoc <- paste0(gLoc,'_pol',1)
gLoc
gLoc <- '/home/tcrnbgh/Scratch/quarry_data/grassdb/quarry'
gdb
paste0(
'grass ',gdb,' --exec v.in.ogr input=',vecLoc,' output=points -o --o'
)
?system
readAll
?readAll
pd <- prepDataTrunc[[70]]
pd$pol
pd
st_crs(trainingData$sf) <- st_crs(27700)
file.remove(paste0('vector/intout_',maskPoly$fid,'_training.gpkg'))
?readAll
f <- 'data/prepData_alllocs_maxdiff01_smpper0.RDS'
prepData <- readRDS(f)
setwd("~/Documents/git/quarry_hpc")
f <- 'data/prepData_alllocs_maxdiff01_smpper0.RDS'
prepData <- readRDS(f)
print('done!')
print('running interpolations...')
prepDataTrunc <- prepData[1:70]
prepDataTrunc[[70]]$tiles$b
# intRasters <- intA
# foldedRas <- pd$foldA
# tiledRas <- pd$tiles$b
prepDataTrunc[[70]]$tiles$b
intRasters=intA
# the earlier survey to compare against
compareRas <- tiledRas$b
fr = foldedRas
# test data below is essentially the original raster
# ep <- pd$pol
# fr <- foldedRas
# cr <- compareRas.r
raslist <- intRasters$ras[[1]]
?readAll
grassGISDBASE
grassGISDBASE <- paste0(userDataDir,'/grassdb')
grassGISDBASE
userDataDir
gLoc = grassGISDBASE
# grass params
# generate unique grass location name
gnLoc <- paste0(gLoc,'_pol',1)
gnLoc
gLoc
gnLoc <- paste0(gLoc,'_pol',pd$pol$fid)
# grass params
# generate unique grass location name
gnLoc <- paste0(gLoc,'_pol',1)
gnLoc
# grass params
# generate unique grass location name
gnLoc <- paste0(gLoc,'/grass_pol',1)
gnLoc
# grass params
# generate unique grass location name
gnLoc <- paste0(gLoc,'/grass_pol',pd$pol$fid)
gnLoc
if (dir.exists(gnLoc)) unlink(gnLoc,recursive=T)
print(gdb)
gdb <- paste0(gnLoc,'/PERMANENT')
gdb
paste0('vector/intout_',maskPoly$fid,'_training.gpkg')
paste0(getwd(),'/raster')
Sys.sleep(1)
# prepare data --------------------------------
print('loading prepped data...')
f <- 'data/prepData_alllocs_maxdiff01_smpper0.RDS'
prepData <- readRDS(f)
print('done!')
print('truncating prepData...')
prepDataTrunc <- prepData[1:70]
print('done!')
pd <- prepData[[22]]
getwd()
maskPoly <- list(fid = 22)
# prepare rasters
mLoc <- paste0(getwd(),'/raster/intout_',maskPoly$fid,'_ras_training.tif')
mLoc
allRas <- trainingData$ras[[1]] %>% st_as_stars %>%
st_set_crs(st_crs(27700)) %>% as(.,'Raster')
# not sure why rasters were merged??
# allRas <- merge(trainingData$ras[[1]],testData$ras[[1]]) # weird?
# overwritten below:
library(raster, stars)
# not sure why rasters were merged??
# allRas <- merge(trainingData$ras[[1]],testData$ras[[1]]) # weird?
# overwritten below:
library(raster, stars, dplyr)
allRas <- trainingData$ras[[1]] %>% st_as_stars %>%
st_set_crs(st_crs(27700)) %>% as(.,'Raster')
# not sure why rasters were merged??
# allRas <- merge(trainingData$ras[[1]],testData$ras[[1]]) # weird?
# overwritten below:
library(raster, stars, dplyr,tidyr)
# not sure why rasters were merged??
# allRas <- merge(trainingData$ras[[1]],testData$ras[[1]]) # weird?
# overwritten below:
library(raster, stars, dplyr, stringr)
library(stars), dplyr, stringr)
library(stars)
library(dplyr)
allRas <- trainingData$ras[[1]] %>% st_as_stars %>%
st_set_crs(st_crs(27700)) %>% as(.,'Raster')
maskPoly = pd$pol
trainingData <- pd$foldA$train
testData <- pd$foldA$all
# object for storing run times
intTimes <- list()
# object for storing interpolated rasters
rasterlist <- list()
# prepare rasters
mLoc <- paste0(getwd(),'/raster/intout_',maskPoly$fid,'_ras_training.tif')
allRas <- trainingData$ras[[1]] %>% st_as_stars %>%
st_set_crs(st_crs(27700)) %>% as(.,'Raster')
allRas
plot(allRas)
print('writing training data as tif...')
writeRaster(allRas,
mLoc,
overwrite=T)
allRas
?writeRaster
write_stars(allRas,
mLoc)
allRas <- trainingData$ras[[1]] %>% st_as_stars %>%
st_set_crs(st_crs(27700))
print('writing training data as tif (stars method)...')
write_stars(allRas,
mLoc)
allRas
mLoc
write_stars(allRas,
mLoc)
write_stars(allRas,
mLoc)
?write_stars
pd <- prepData[[23]]
maskPoly = pd$pol
trainingData <- pd$foldA$train
testData <- pd$foldA$all
# prepare rasters
mLoc <- paste0(getwd(),'/raster/intout_',maskPoly$fid,'_ras_training.tif')
allRas <- trainingData$ras[[1]] %>% st_as_stars %>%
st_set_crs(st_crs(27700))
print('writing training data as tif (stars method)...')
write_stars(allRas,
mLoc)
?write_stars
print(tempdir())
tempdir()
intTimes
